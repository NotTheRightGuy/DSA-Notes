Probabilistic algorithms are important in cryptography. On the one hand, the algorithms used in encryption and digital signature schemes often include random choices (as in Vernam’s one-time pad or the DSA) and therefore are probabilistic. On the other hand, when studying the security of cryptographic schemes, adversaries are usually modeled as probabilistic algorithms. The subsequent chapters, which deal with provable security properties, require a thorough understanding of this notion. Therefore, we clarify what is meant precisely by a probabilistic algorithm, and discuss the underlying probabilistic model. The output y of a deterministic algorithm A is completely determined by its input x. In a deterministic way, y is computed from x by a sequence of steps decided in advance by the programmer. A behaves like a mathematical mapping: applying A to the same input x several times always yields the same output y. Therefore, we may use the mathematical notation of a mapping, A : X −→ Y , for a deterministic algorithm A, with inputs from X and outputs in Y . There are various equivalent formal models for such algorithms. A popular one is the description of algorithms by Turing machines. Turing machines are state machines, and deterministic algorithms are modeled by Turing machines with deterministic behavior: the state transitions are completely determined by the input. A probabilistic algorithm A is an algorithm whose behavior is partly controlled by random events. The computation of the output y on input x depends on the outcome of a finite number of random experiments. In particular, applying A to the same input x twice may yield two different outputs. This includes [[Bloom Filter]] and [[HyperLogLog]].