**NP-complete problem**, any of a class of computational problems for which no efficient solution [[Algorithm]] has been found. Many significant computer-science problems belong to this class—e.g., the [[The traveling salesperson]] satisfiability problems, and graph-covering problems.

So-called easy, or [tractable](https://www.britannica.com/technology/tractable-problem), problems can be solved by computer  that run in [polynomial time](https://www.britannica.com/science/polynomial-time-algorithm); i.e., for a problem of size _n_, the time or number of steps needed to find the solution is a [polynomial](https://www.britannica.com/science/polynomial)function of _n_. Algorithms for solving hard, or [intractable](https://www.britannica.com/technology/intractable-problem), problems, on the other hand, require times that are exponential functions of the problem size _n_. Polynomial-time algorithms are considered to be efficient, while exponential-time algorithms are considered inefficient, because the execution times of the latter grow much more rapidly as the problem size increases.

A problem is called NP ([nondeterministic](https://www.britannica.com/science/NP-problem) polynomial) if its solution can be guessed and verified in polynomial time; nondeterministic means that no particular rule is followed to make the guess. If a problem is NP and all other NP problems are polynomial-time reducible to it, the problem is NP-complete. Thus, finding an efficient [[Algorithm]] for any NP-complete problem implies that an efficient algorithm can be found for all such problems, since any problem belonging to this class can be recast into any other member of the class. It is not known whether any polynomial-time algorithms will ever be found for NP-complete problems, and determining whether these problems are tractable or intractable remains one of the most important questions in theoretical [computer science](https://www.britannica.com/science/computer-science). When an NP-complete problem must be solved, one approach is to use a polynomial algorithm to approximate the solution; the answer thus obtained will not necessarily be optimal but will be reasonably close.

## How do you tell if a problem is NP-complete?
NP-complete problems show up everywhere! It’s nice to know if the problem you’re trying to solve is NP-complete. At that point, you can stop trying to solve it perfectly, and solve it using an approximation algorithm instead. But it’s hard to tell if a problem you’re working on is NP-complete. Usually there’s a very small diference between a problem that’s easy to solve and an NP-complete problem. For example, in the previous chapters, I talked a lot about shortest paths. You know how to calculate the shortest way to get from point A to point B.

But if you want to ind the shortest path that connects several points, that’s the traveling-salesperson problem, which is NP-complete. he short answer: there’s no easy way to tell if the problem you’re working on is NP-complete. Here are some giveaways:

- Your algorithm runs quickly with a handful of items but really slows down with more items.
- “All combinations of X” usually point to an NP-complete problem.
- Do you have to calculate “every possible version” of X because you can’t break it down into smaller sub-problems? Might be NP-complete.
- If your problem involves a sequence (such as a sequence of cities, like traveling salesperson), and it’s hard to solve, it might be NP-complete.
- If your problem involves a set (like a set of radio stations) and it’s hard to solve, it might be NP-complete.
- Can you restate your problem as the set-covering problem or the traveling-salesperson problem? hen your problem is deinitely NP-complete.
